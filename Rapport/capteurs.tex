\section{Détail de la conception de la partie microcontrôleur du projet}
	\subsection{Le capteur}
		Lors de la réalisation du capteur il a fallu en premier lieu se fixer
		des objectifs à atteindre, afin d'être sur d'aller dans une direction
		cohérente tout a long du projet. De  ce fait nous avons choisi d'opter pour
		la réalisation d'un prototype fonctionnel et relativement simple au début.
		Par relativement simple, nous entendions capable de lire un ou deux capteurs
		analogiques simples à mettre en place de manière à nous focaliser sur
		l'interfaçage du dispositif avec un serveur de données. Nous nous sommes
		donc d'avantage focalisés sur une approche plus logicielle du projet en
		écartant volontairement, par manque de temps, des considérations annexes
		comme la gestion de l'énergie ou la mise en place immédiate de capteurs
		très complexes. Le but était réellement de fournir une base saine sur laquelle
		il serait facile de se baser à l'avenir.
		
		\subsubsection{La partie électronique}
		
		La partie électronique est la plus simple de l'appareil c'est donc celle
		là qui sera abordée en premier. Elle se compose simplement d'une photo résistance
		montée en pull up sur la patte analogique 1 de l'Arduino et d'un capteur de
		température câblé sur la patte analogique 2. Nous avons également câblé un bouton de
		mise à jour (dont l'utilité sera détaillée plus tard) sur la patte PD2
		ainsi que la real time clock sur trois pattes numériques de manière à pouvoir
		échanger des données. Tout ces composants ont été positionnés sur une breadboard
		de manière à ce que nous puissions facilement en modifier l'arrangement au fur et a mesure
		que nos besoins évoluaient dans le projet.
		\par
		Nous n'avons malheureusement pas eu le temps de réaliser de carte
		pour fixer ce design. Et il n'aurait pas été pertinent de le faire dans la mesure
		ou la conception, le routage et la fabrication d'une carte sont des activités pour
		le moins chronophages et qu'il a effectivement été plus productif pour nous de nous
		concentrer sur l'ajout de nouvelles fonctionalités au capteur. Cependant
		nous avons édités des PCB et des schémas électroniques disponibles en
		annexe qui permettent de réaliser une telle carte.
		
		\subsubsection{Conception du firmware de l'Arduino}
		La conception du firmware de l'arduino s'est découpée en plusieurs étapes.
		Pour commencer nous avons séparé les différentes fonctionnalités que nous
		souhaitions. D'un point de vue organisation cela s'est traduit par un fractionnement
		du code en plusieurs fichiers, chacun regroupant les fonctions relatives à un
		domaine, par exemple la gestion du port série, des CAN, de l'EEPROM et autre.
		\par
		Ensuite, une fois que la séparation logique des fonctionalités a été effectuée
		nous avons commencé à les développer une à une, en lançant à chaque fois une
		série de tests sur ce que nous avions créé, de manière à nous assurer que tout
		était bien conforme à ce que nous attendions. De cette manière nous pouvions
		réutiliser sans crainte du code ue nous aviosn précédemment écrit puisqu'il
		avait été validé par une batterie de tests.
		\par
		Une attention toute particulière a été portée à la doc. En effet si nous
		souhaitons que le projet puisse être repris les années suivantes il
		est indispensable de fournir une documentation valable, fiable et complète
		de manière à ce que n'importe qui ouo presque soit en mesure de comprendre
		ce qui a déjà été réalisé de manière logicielle. Pour ce faire nous avont eu
		recours au système de documentation in-code Doxygen, qui grâce à un
		système de commentaires au formattage particulier permet de générer automatiquement
		une belle documentation HTML. Cette documentation navigable est facile à utiliser, avec outils
		de recherche intégré et liens entre les différentes fonctions documentées.
		Si vous souhaitez construire la documentation du programme rendez vous dans
		le répertoire Arduino et tapez simplement \texttt{doxygen} un dossier contenant
		le nécessaire sera généré pour vous !
		\par
		La seconde partie du projet, qui n'est au final même pas utilisée dans le prototype
		actuel, a été la réalisation d'un driver pour la real time clock de Maxim DS1302. En
		effet, nous somme parti du constat que le fonctionnement du WiFi pouvait être parfois
		assez instable, et que de ce fait il serait appréciable que le capteur puisse se comporter
		comme une sorte de datalogger dans le cas où il serait dans l'incapacité momentanée de communiquer
		avec le serveur de donnée, que cela soit a cause du wifi ou d'un autre problème d'ailleurs.
		Pour cela nous avions pensé le coupler avec une flash (voir les schémas en annexe). Cela dit
		comme le composant n'était disponible qu'en format SOIC8 et que nous n'avons pas réalisé la carte
		il nous a été impossible de l'intégrer correctement. Une amélioration possible et très facile à
		mettre en oeuvre pour le projet serait donc l'intégration de cette flash et l'utilisation
		de la RTC pour soumettre en différé des données de mesures qui n'aurais pas pu être
		transmises à temps.
		\par
		La troisième partie du projet a été consacrée à faire en sorte que la configuration du capteur
		soit persistante entre les reboots. Durant les phases de développement nous ne nous étions pas
		vraiment occupé de cela mais dès que le programme est devenu plus compliqué il est devenu
		essentiel de stocker certains paramètres (d'identifications notamment) autrement qu'en dur
		dans le code. Il a donc fallu ajouter un module de gestion de l'EEPROM. La structure suivante a donc
		été choisie pour stocker des données :
		\begin{itemize}
			\item L'EEPROM est découpée en différents secteur de taille fixé à la compilation
			\item Chaque secteur contient un octet de taille et $N$ octets de données ($N < 255$)
			\item Chaque secteur est uniquement défini par sa position en mémoire
		\end{itemize}
		
		Cette solution présente l'avantage d'être très simple à mettre en place d'un point de vue
		logiciel, ce système souffre cependant d'un gros problème qui est que l'on ne peut
		pas connaitre de manière dynamique la taille maximale des données que l'on peut ranger
		dans un segment. Ce qui implique que le programmeur fasse très attention aux données qu'il
		manipule, de manière à ne pas provoquer de débordement sur un autre segment. Ceci dit,
		ce problème n'est pas vraiment critique puisqu'une simple réécriture de la configuration
		rétablira tout correctement. Ceci fait également partie des améliorations possibles
		du projet.
		
		\par
		La quatrième partie du projet a sans aucun doute été la plus difficile à réaliser. En
		effet après s'être occupé des briques élémentaire qui compose le capteur (communiquer
		en série, lire des capteurs analogiques, lire la RTC). Il a fallu regrouper tout ça
		ensemble et l'envoyer sur internet. Pour se faire, il a d'abord fallu comprendre comment
		fonctionnait la carte WiFi. La datasheet n'étant pas toujours très claire, ni très complète
		il a d'abord fallu passer par une phase \og{} d'exploration \fg{} de la carte via le port
		série, de manière à comprendre précisément ce qu'elle attendais de nous en terme de commandes.
		La carte se configurait finalement par un set de commandes AT via le port série et malgré
		les quelques imprécisions de la datasheet nous avons finalement été capables de nous identifier
		sur un réseau spécialement créé pour l'occasion.
		
		\par
		A partir de là a été développé une petite bibliothèque qui intègre les fonctions réseau de base,
		à savoir s'identifier sur un réseau avec des paramètres donnés, soumettre des requêtes HTTP et
		vérifier le retour des commandes AT de manière à réitérer plusieurs fois une tentative de connexion
		qui aurait échouée.
		
		\subsubsection{Interaction du capteur avec les internets}
		
		\subsubsection{Principales difficultés rencontrées}
		
	\subsection{Configurator.py}
